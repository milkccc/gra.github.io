# 7.实现微服务：Bot代码的执行
## 本章主要内容
本节课把代码执行的微服务写完
负责接收一段代码，把代码扔到我们的队列当中、每一次我们去运行一段代码
运行结束之后、把我们的结果返回给我们的服务器
![Alt](https://cdn.acwing.com/media/article/image/2022/08/19/167993_e7c151751f-4426bd545bc9427b964f5384f70d76e.png)
### 1.创建后端 botrunningsystem
#### 配置依赖：
先把依赖从matchingsystem的pom.xml复制过来,
我们需要动态的把用户传过来的Java代码编译然后执行,需要加入依赖joor-java-8。用Java的代码的写法举例子
#### 实现任意语言
未来自己实现的时候可以换成任意语言、在这个线程里面是有一堆的bot代码等待执行
然后我们会有一个队列、每次我们从队列中取出一个bot代码来执行
执行的时候用的是一个Java的包会方便的去帮我们动态编译一段Java代码
未来可以在云端把他换成一个docker、你在云端自动启动一个docker容器
给docker设置一个内存上限200M再去docker中动态执行一段Java代码用timeout
去限制某一个程序的执行时间、这样又安全又可以支持其他语言
所以这里我们用Java一个包来动态执行一段Java代码
开一个线程用我们的joor去动态执行一段代码
### 2.实现botrunningsystem中的Service和Controller
![Alt][pic1]
### 3.前端加入选择框
![Alt](https://cdn.acwing.com/media/article/image/2022/08/19/167993_deaf5f1a1f-9a13fd5a60be7eda2e2f5c84a1caa50.png)
### 4.把前面每一个通信都加上BotId
前面通信的时候每一次通信都是没有加botid的
userid、我们需要把前面每一个通信都加上botid 对应service层也要加上
发的时候收的时候都需要传我们的id
### 5.判断人或者鸡+编码
在创建完地图执行nextstep的时候
判断一下当前的玩家是人还是代码、如果是代码的话就需要像我们的微服务发送一
段代码、然后让她自动去算、如果是人来操作的话就要等待用户的输入
所以这里需要判断一下如果player的botid=-1的话表示是由人来操作
编码的时候我们随意编只要把我们的编码编成字符串就可以
第一段传的是地图信息、中间用#号隔开
### 6.消费者生产者模型
微服务可以不断的去接收用户的一个输入
当接收的代码比较多的时候、我们应该把他们所有接收到的代码放到一个队列里面
我们每接收到一个任务、消费者是一个单独的线程
苦力不断是完成任务，每来一个任务检测队列是否为空如果队列不空，从对头拿出
代码执行、执行完之后再去检查
### 7.consume里面开一个新的线程
consume里面开一个新的线程
如果被awit阻塞住后就会被唤醒、然后执行
实现一下consume操作、需要在consume里面开一个新的线程
这样我们就可以从前端动态的传一份代码过来传完之后动态的编译一遍
编译完之后我们就可以动态的调用它编译后的结果
![Alt](https://cdn.acwing.com/media/article/image/2022/08/19/167993_f9ac04161f-608c69b9dc7f8d616e5546bc45db894.jpg)



[pic1]:https://thumbnail1.baidupcs.com/thumbnail/7d74704c9s99388b8fc91773c6deb66c?fid=828221211-250528-831765541552183&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-vxkBnQT4wnSBoe%2bjiCz8fta9%2bBU%3d&expires=8h&chkbd=0&chkv=0&dp-logid=8842559422169724006&dp-callid=0&time=1701147600&size=c1536_u864&quality=90&vuk=828221211&ft=image&autopolicy=1
