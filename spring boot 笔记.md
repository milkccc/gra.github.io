# 6. 实现微服务：匹配系统
## 6.1 
### 1. 实现匹配系统的原理剖析

**匹配过程**

匹配系统就是一个单独的程序就类似于MySQL,生成地图的过程在用户本地、两名玩家在本地实现地图,地图就大概率不一样。
所以需要**将生成地图过程放在服务器中**,Game任务需要生成统一的地图、Game第一步先生成一个地图CreateMap,
有很多逻辑都需要在服务器端完成，判断蛇输赢的逻辑,当我们撞的时候死亡。如果在客户端用户本地就可以作弊,
所以说我们**整个游戏的过程应该都放到服务器端**、不止生成地图这个过程,同时**蛇的移动、蛇的判定**都要在服务器端统一完成,
服务器端判断完之后再把结果返还给前端，前端只是用来画动画（渲染）的,前端不做任何判定逻辑、
（并不是所有的游戏判定逻辑都在云端,回合制通信量比较少、比如吃鸡各种fps游戏在本地操作非常频繁,
如果都在云端的话延迟会非常高、判断是否击中对方的逻辑判断就是在本地,所以要在游戏体验在用户作弊之间做一个权衡。
锁头挂之类的,炉石所有逻辑判断都在云端、很难作弊,整个我们在云端维护游戏过程它的整个流程.）
![Alt](https://cdn.acwing.com/media/article/image/2022/08/10/167993_6a69e45718-f0ec9ef326f064a25bce510c9b6d73c.png)
- 都点击匹配向服务器发出请求匹配系统不会立即返回结果，一般会匹配个几秒
- 整个游戏是**异步**的过程，计算量比较大的过程，所以我们就另外写一个进程
- 后端接收的请求，会将用户的请求，发送给我们的匹配系统，匹配系统维护了一堆用户的集合
- 匹配系统里有很多很多的用户，将**当前用户中战斗力最相近的几个人匹配到一起**
- 然后将我们的匹配结果返回给网站后端返回给serverSpringBoot
- 返回之后我们的后端就会把结果返回给前端、我们在前端就可以看到匹配的对手是谁
- 整个匹配的过程其实是一个异步的过程、匹配的过程会经过一段比较长的时间
- 什么时候有匹配结果我们是未知的
![Alt](https://cdn.acwing.com/media/article/image/2022/08/10/167993_e198eb4218-583a568f3eac7780e988f3afd8832c2.png)

### 2. WebSocket协议与http协议区别
- 一问一答式http， 问一次返回多次中间还有间隔时间
- 这种情况下https就不能满足要求了
- websocket协议不仅客户端可以主动像服务器发送请求、服务器端也可以主动向客户端发送请求
- 是两遍对称的一个通信方式
![Alt](https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuamF2YXpoaXlpbi5jb20vd3AtY29udGVudC91cGxvYWRzLzIwMjAvMDcvamF2YTctMTU5NTE0MjA3Ni5wbmc?x-oss-process=image/format,png)

### 3. 在云端维护游戏的整个流程
- 先 生成一个地图，将地图传给两个客户端，传完之后等待用户输入
- 可以从代码端获取下一步操作也可以客户端返还
- 代码端要用微服务了，waiting可以写一个死循环每次循环前先sleep一秒钟
- 然后判断一下是否两条蛇的下一步操作都有了
- 如果有的话进行下一步
- 如果没有的话继续等待、当然我们可以设定一个最大时间最大5s
- 如果5s之内没有得到下一步操作的话、我们就判断没有输入操作的蛇输
- 如果超时就判断输赢、如果获得输入写一个judge程序、判断是否合法和撞墙、这个游戏的逻辑
### 4. WebSocket协议原理剖析
   基本原理就是: 每一个连接我们都会在后端维护起来
   我们会把前端建立的每一个websocket连接在后端维护起来，
   比如我们的Clint1连接到我们的服务器、其实一个连接就是一个类
   其实就是一个websocketserver类，每来一个连接，其实就是new一个这个类的实例
   先创建这个类，我们每次来一个连接的时候本质上就是new一个这个类的实例
   每一个连接都是这个类的一个实列来维护的、所有和这个连接相关的信息
   都会存到这个类里面、如果是每一个连接自己独有的信息、比如说维护这个连接对应的用户是谁
   那可以存成私有变量、如果是维护所有连接的公共信息
   比如我们想去维护一下当前哪些用户建立的连接、那么可以存成一个静态变量
   WebSocket就是一个多线程、每来一个连接就会开一个新的线程来维护它这个websocket就是一个类
   每来一个连接就会开一个线程创建一个类，去维护这个连接流程
   用户开始匹配的时候向后端发送一个请求、就会在后端websocket里new一个新的类开一个线程
   来维护这个链接那么接收到这个请求之后、我们会把我们的信息发送给我们的匹配系统
   匹配系统是一个单独的额外的程序、匹配系统当接收到很多的用户之后随着时间的推移
   出现两名玩家的战斗力比较接近匹配出来一局、匹配系统就会将信息返回给我们的后端服务器
   也就是我们的websocket服务器、websocket服务器接受到这个信息之后就会将这个信息返回
   给这局对战的两名玩家、根据两名玩家建立的链接返还到他们的前端的浏览器里面
   同时在我们的服务器端创建一个游戏的过程、因为整个游戏的判断地图的生成都是在云端进行的
   这就是websocket的基本原理
### 5. 集成WebSocket
- 在pom.xml文件中添加依赖：
```agsl
spring-boot-starter-websocket
fastjson
```
![Alt](https://cdn.acwing.com/media/article/image/2022/08/10/167993_4f9b6d5018-1d7314e5e4d2c15815853f1d85bdd4e.png)
### 6. 实现从后端向前端发信息
   从后端向前端怎么发信息、需要自己实现一下
   首先用websocket的一个api、建立链接的时候需要把session存下来
   如何从后端向前端发信息呢、写一个辅助函数，异步通信需要加一个锁
   异步通信需要加一个锁、我们要知道这个链接对应的是谁
   才知道谁跟谁匹配到一块了，另外我们还需要存储一下所有链接
   因为当我们接收到一个信息之后，比如当我们从匹配系统接收到某一局匹配成功的信息之后
   我们需要将这个消息发送给匹配成功的两名玩家、我们需要能够根据用户的id找到它对
   应的链接是谁，才可以利用这个链接向前端发请求，所以对于所有的websocket可见的一个全局变量
   用来存储所有的链接、对于所有的实列可见定义为静态变量
   由于每个实例在每个线程里面，所以公共的变量是线程安全的用线程安全的哈希表
   将userid映射到我们的websocket实例
### 7. WebSocketServer
   当我们建立链接的时候我们需要从token中读取当前的用户是谁，
   有了id之后去插数据库去查id是谁，查数据库注入userMapper
   静态变量相当于是所有实例的一个全局变量，
   如果不加静态变量的话那就是所有的实列所有独有一份，哈希表是对所有的实例都可见
   每一个实例都要访问同一个哈希表，不加static 相当于局部变量
   websocketserver，并不是一个标准的spring里的组件，注入的时候跟controller是有所区别的
   静态变量访问的时候需要用类名访问
### 8. 配置config.SecurityConfig
```agsl
@Override
public void configure(WebSecurity web) throws Exception {
    web.ignoring().antMatchers("/websocket/**");
}
```
配置config.SecurityConfig、然后去前端写一写调试一下整个过程
放行这一类所有链接、创建一个从后端到前端建立一个链接
需要当我们的组件加载出来的时候建立一个链接
把周期函数取出来、另外我们可以将socket存到另外一个变量里面
当当前组件被挂载的时候，我们需要创建一个链接
### 9. 加上jwt验证
我们现在建立链接的时候、直接把用户id传过来就可以建立链接了
这样就可以实现一个身份的验证、如果可以正常解析出来的话就表示登录成功
### 10. 实现前端页面,匹配界面布局
![Alt](https://cdn.acwing.com/media/article/image/2022/08/10/167993_89ab57fe18-fcbbb0d78eba02064fa7daea87c8fe8.jpg)
### 11. 前端实现——开始实现具体逻辑
我们向后端发送一个请求、后端接收到请求之后将用户放到匹配池中
当匹配池子满了之后、返回给后端，后端返回给client
事件怎么区分呢，取消和开始匹配
### 12. 写匹配池
![Alt](https://cdn.acwing.com/media/article/image/2022/08/10/167993_8ffc633618-0fae2269b81f0bfb00e509328d14635.jpg)

## 6.2
### 1. 同步两个玩家的位置思路解析
除了地图同步以外、我们还需要同步两个玩家的位置
同步玩家的位置我们可以标记一下、至于谁在A谁在B我们需要在云端确定
确定完之后我们会把每一个玩家的位置传给前端，我们可以傻瓜式的确定a在左下角b在
右上角、我们在存地图的时候需要存一下玩家的id和位置
在game这个类里我们需要加一个player类来维护玩家的位置信息
一般开发思路需要用什么定义什么、先定义需要用到的各种函数
有参构造函数无参构造函数、存一下每个玩家每一次的指令是什么
![Alt](https://cdn.acwing.com/media/article/image/2022/08/12/167993_4b3502e91a-12ced28ab24e5852bce7b738e0439b6.png)
### 2. 实现了三个棋盘的同步原理
现在有三个棋盘状态同步的机制（一个在云端,有两个浏览器即两个client）
client向云端发送消息表示这个蛇动了一下、当服务器接收到两个蛇的移动之后
服务器就会把两个蛇移动的信息分别返回给Client1，client2 ，同步给两名玩家、这样我们就实现了三个棋盘的同步
！[ALt](https://cdn.acwing.com/media/article/image/2022/08/12/167993_d9f042991a-fb6980e6561affb2c4e55c33b0240ba.png)
### 3. 初始化一下我们的playerAplayerB
首先我们构造map的时候传入两名玩家的userid、初始化一下我们的playerA和playerB
为了需要访问到我们的player、我们需要写两个函数
后端就可以把两个玩家的信息传过去、前端做出相应修改
### 4. 什么是线程为什么要用多线程？
Game不能作为单线程来处理、线程：一个人干就是单线程，两个人干就是多线程
涉及到两个线程之间的通信以及加锁的问题
我们需要先把game变成一个支持多线程的类
就变成多线程了、我们需要实现thread类的一个入口函数
(alt+insert就可以实现、重载run函数)
start函数就是thread函数的一个api、可以另起一个线程来执行这个函数
为了方便我们需要先把我们的game存放到这个类里面
我们的线程就要一步一步等待下一步操作的操作
### 5. 如何去实现等待两名玩家输入
两名玩家都输入我们就进行下一步
如果超过一定时间之后两名玩家还没有输入的话
我们要结束这个操作、告诉我们哪个玩家没有输入,谁就输了、可以用sleep函数、如果是正在进行中的话
我们应该将这一步操作广播给两位玩家、需要同步一下
我们从服务器分别接收到两名玩家的输入之后、需要将两名玩家的输入分别广 播给两个人。
比如说我们两个玩家，同时都向服务器发送了请求
c1不知道c2的操作s向c1c2广播操作
### 6. 前端向后端发消息
当我们移动的时候、之前我们是在gamemap里面判断的
两个线程同时操纵一个变量、至少有一个变量是写的话那就需要加锁lock
前端写完之后后端需要接收到这个请求
gameobject需要存下来才能访问到蛇、每一个新的游戏都会new一个新的类
都会开一个新的线程
### 7. 在数据库中创建表record
```
record表用来记录每局对战的信息
表中的列：
id: int
a_id: int
a_sx: int
a_sy: int
b_id: int
b_sx: int
b_sy: int
a_steps: varchar(1000)
b_steps: varchar(1000)
map: varchar(1000)
loser: varchar(10)
createtime: datetime
```